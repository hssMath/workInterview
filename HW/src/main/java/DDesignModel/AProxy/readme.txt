接口与抽象类的区别：
    抽象重点描述的是一个具体的概念；接口描述的是一类事物某方面的共同特征。
    1、接口强调特定功能的实现，而抽象类强调所属关系。
    2、接口是设计的结果，抽象类是重构的结果。
    3、抽象类主要用来抽象类别，接口主要用来抽象功能。

1、代理模式
    代理模式是一种比较好理解的设计模式。简单来说就是 我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，
提供额外的功能操作，扩展目标对象的功能。
    代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。
    代理模式有静态代理和动态代理两种实现方式。

2、静态代理
    静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象
    都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。
    上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。

3、动态代理
    相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类
    (CGLIB动态代理机制)。从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。
    说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。

    就 Java 来说，动态代理的实现方式有很多种，比如 JDK 动态代理、CGLIB 动态代理等等。

4. JDK动态代理和CGLIB动态代理对比
    JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理
        类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。
    就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。

5、静态代理和动态代理的对比
    灵活性：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口
        一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
    JVM 层面：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的class文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

cglib:是一个强大的，高性能的，高质量的code生成类库。它可以在运行期间扩展java类和实现java接口。广泛应用于使用了AOP的框架，eg：springAop。
1.使用jdk的proxy实现动态代理，要求目标类与代理类要实现相同的接口。如目标类不存在接口，则无法使用该方式实现。
2.对于无接口的类，要为其创建动态代理，就要使用cglib实现。
    其生成原理是：生成目标类的子类，要求目标类能够被继承，而且生成的子类是被增强过的，这个子类对象就是代理对象。所以，使用cglib生成动态代理，
    要求目标类必须能够被继承，即不是被final修饰的类。

对比：cglib经常被用于框架中，eg：spring,Hibernate等，Cglib的效率高于jdk。